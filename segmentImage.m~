function [labels, peaks] = segmentImage(image, params);
figure;
imshow(image);

% xyz = rgb2xyz(img);
% luv_cform = makecform('xyz2uvl');
% luv_img = applycform(xyz, luv_cform);
% figure;
% imshow(luv_img);

%call mean shift
%merge peaks if they are close to eachother <= r/2

[rows, cols, dim] = size(image);
image = double(image);
data = zeros(rows * cols, dim);
peaks = zeros(rows * cols, 1);
labels = zeros(rows, cols);
tree = createns(data); %makes the search faster
mergedPeaks = [];
mergeIndices = [];

for i=1:rows
    for j=1:cols
        for k=1:dim
            data((i - 1) * cols + j, k) = image(i, j, k);
        end
    end
end

noOfLabels = 0;

for i=1:rows*cols

    %get the data indices that are inside the window close to cur pixel
    neighbors = rangesearch(tree, data(i), params(1));
    neighbors = neighbors{1};
    
    if(labels(i/rows+1, mod(i,rows)+1) == 0) %not visited
        
    end
    
    %find peak of current pixel
    curPeak = meanshift(data, i, params);
    if (isempty(peaks))
        peaks(noOfLabels+1) = curPeak;
    end
    
    %check if it can be merged 
    for p=1:length(peaks)
        if(norm(curPeak, peaks(p)) <= params(1)/2) %merge!
            peaks(p) = (peaks(p) + curPeak)/2; %new mean for merged peaks
            labels(i/rows+1, mod(i,rows)+1) = p; %CHECK 
        else %new peak, create new label
            noOfLabels = noOfLabels + 1;
            peaks(noOfLabels) = curPeak;
            labels(i/rows+1, mod(i,rows)+1) = noOfLabels; %CHECK INDICES
        end
    end
end

end
