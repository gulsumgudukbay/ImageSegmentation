function peak = meanshiftLUVXY(data, i, params)

[n, dim] = size(data);

%mean and deviation
sigma = 1;
h = std(data) * (4/3/n)^(1/5); % Silverman's rule of thumb (wiki)
phi = @(x)(exp(-.5 * x.^2) / sqrt(2*pi*sigma^2)); % normal pdf (wiki)

treeLUV = createns(data(:, 1:2)); %makes the search faster
treeXY = createns(data(:, 4:5)); %makes the search faster

curLoc = data(i, :);

while 1
    
    %get the data indices that are inside the window
    insideWindowIndicesluv = rangesearch(treeLUV, curLoc(1:2), params(1));
    insideWindowIndicesluv = insideWindowIndicesluv{1};
    
    insideWindowIndicesxy = rangesearch(treeXY, curLoc(4:5), params(2));
    insideWindowIndicesxy = insideWindowIndicesxy{1};
    
    %[insideWindowIndices,ia,ib] = intersect(insideWindowIndicesluv,insideWindowIndicesxy);
    
    %formula
    quotient = zeros(1, 2);
    divisor = zeros(1, 2);
    quotient2 = zeros(1, 2);
    divisor2 = zeros(1, 2);
    %gaussian mean calculation 
    %source: "Mean Shift: A Robust Approach toward Feature Space Analysis"
    for x=1:length(insideWindowIndicesluv)
        kprime = phi(((curLoc - data(insideWindowIndicesluv(x), :)) / h).^2);
        divisor = divisor + kprime;
        quotient = quotient + curLoc(1:2) .* kprime;
    end
    for x=1:length(insideWindowIndicesxy)
        kprime2 = phi(((curLoc - data(insideWindowIndicesxy(x), :)) / h).^2);
        divisor2 = divisor2 + kprime2;
        quotient2 = quotient2 + curLoc(4:5) .* kprime2;
    end
    
    meann = [(quotient ./ divisor) (quotient2 ./ divisor2)];
    
    %if the current location's distance to the mean is smaller than the
    %stopping threshold, it has converged!
    locc = [curLoc(1:2) curLoc(4:5)];
    if(norm(locc-meann) < params(3))
        break; %converged!
    end
    
    %translate the point to the mean
    curLoc = meann;
    
end

peak = meann;

end
